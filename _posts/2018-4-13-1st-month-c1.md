---
layout: post
title:  First Month Work Summary
author: gassa
comments: true
category: work-notes
tags: [proxy, test, aws]
published: false
---


Monthly Work Summary: 03-12-2018 to 04-12-2018

## Achievement:
* Understand my team's product, Token Generation Service, implemented in Lagom, a microservice framework in Scala.
* Picture an overview of my department's mission for the entire cooperation.
* Establish an automated software stack for my team's performance test, using Taurus, JMeter, Jenkins and AWS EC2.
* Start Scala99 for practice my programming skills.


## Technologies:

* Hands-on experiences with AWS, EC2, S3, AWS cLi, SNS etc.
* Testing skills with Turaus, JMeter. 
* Scala: concurrent abstractions.

### Unit Tests, Functional Tests, Integeration Tests and Performance Tests


### Conconcurrency and Parallism

Execution context (Scala traits) ~ Java Executor, it is free to execute computation in a new thread, a pooled thread
or the current thread.

`scala.concurrent` implements a global static thread pool, backed by a `ForkJoinCon`.

####scala concurrent practice principles

	> Leaves application thread pools to deal with CPU-bound stuff.
    > Executes Any blocking calls in their related execution context

1. **SHOULD** avoid concurrency if possible
2. **SHOULD** use appropriate abstractions only where suitable - Future, Actors, Rx
   2.1 Scala's Futures and Promises
        _**Goodness**_:
		* Parallelizable by eliminating concurrency concerns.
        * Efficiently multiplexes: submitting a task implicitly to an execution context.
        * Alternative implementation, more simpler and efficient than Scala's standard Future.
        * The model is inherently simple and easy to use
        _**Badness**_:
        * They signal only one value from a producer to a consumer, they are not the best abstraction for stream and
          bi-direction communication.

   2.2 Akka's Actor model
        _**Goodness**_:
        - Di-direction communication over asynchronous boundaries, e.g., WebSocket is a prime candidate for actors.
        - Modeling state machine
        - Strong guarantee of non-concurrency with message processing, i.e., messages are processed one by one in
          actor context.
        - Alternative to in-memory queue for message processing, message queueing is an out of box tool in actor.
        _**Badness**_:
        - Fairly low-level for many tasks
        - Many actors are modeled with lots of state, ending up with with a system that can't be horizontally scaled.
        - Bi-direction communication ends up with data flow that are so complex as to be unmanageable.
        - Actor A sends a message to Actor B, it means it is a stream of events between A and B,
          they are tight coupling as well.
        - Actors, tend to be including uncontrolled side effects and that is error prone, which is opposite of
          FP and not idiomatic Scala.
   2.3 Streaming abstraction as Play's Iterates, Akka Streams, RxJava, Reactive Stream, FX2 and Monix
        _**Goodness**_:
        - Modeling a bi-directional communication between producers and consumers
        - Events flow in one direction and easily transform and compose these streams
        - Depending on implementation, address back-pressure concern by default
        - Simple to use and much more reasonable and composable than actors, with the exposed operators
        _**Badness**_:
        - Only unidirectional, it becomes complicated with bi-directional communications. Actor model is better for
          bi-direction.
        - Stream enforces a strong contract, implementing new operators and data source, but the usage of the stream
          on consumer side is simpler.
3. **SHOULD NOT** wrap purely CPU-bound operation in Scala's standard Futures., e.g, def add(x: Int, y: Int) = Future{x+y}
4. **MUST** use Scala's BlockContext on blocking I/O
5. **SHOULD NOT** block
   ```
   def fetchSomething: Future[String] = ???
   //Later
   val result = Await.result(fetchSomething, 3.seconds)
   result.toUpperCase

   Alternative, just keep the context of Future all the way.
   fetchSomething.map(_.toUpperCase)
   ```
6. **SHOULD** use a seperate thread-pool for blocking I/O,
    _e.g._, calls to JDBC, it is better to create a second thread-pool or execution context.
7. All public APIs **SHOULD BE** thread-safe
8. **SHOULD** _avoid_ contention on shared reads
9. **MUST** provide a clearly defined and documented protocal for each component or actor that communicates over async boundaries.
10. **SHOULD** always prefer single-thread scenarios
11. **MUST NOT** hardcode the thread-pool or execution context,
    Don't do this:
    ```
    import scala.concurrent.ExecutionContext.Implicits.global
    def doSomething: Future[String] = ???
    ```
    Some framework (Play framework application) developers may use different thread pools
    WTD: Pass the execution context around as an implicit parameter.
    It's idiomatic and acceptable this way. Also, implicit parameters should be passed in
    the second group of parameters to avoid confusing implicit resolution. When passed in
    the first group, it allows for method calls like doSomething() that won't compile but
    most IDEs will show them as valid.
    ```def doSomething()(implicit ec: ExecutionContext): Future[String] = ???```
### References:
